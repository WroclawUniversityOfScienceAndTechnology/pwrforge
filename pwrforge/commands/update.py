"""Update project"""

import shutil
import subprocess
from pathlib import Path

from pwrforge import __version__
from pwrforge.commands.docker import get_docker_compose_command, pwrforge_docker_build
from pwrforge.config_utils import (
    add_version_to_pwrforge_lock,
    get_pwrforge_config_or_exit,
)
from pwrforge.file_generators.cicd_gen import generate_cicd
from pwrforge.file_generators.cmake_gen import generate_cmake
from pwrforge.file_generators.conan_gen import generate_conanfile, generate_conanprofile
from pwrforge.file_generators.docker_gen import generate_docker_compose
from pwrforge.file_generators.env_gen import generate_env
from pwrforge.file_generators.readme_gen import generate_readme
from pwrforge.file_generators.tests_gen import generate_tests
from pwrforge.file_generators.vscode_gen import generate_vscode
from pwrforge.global_values import PWRFORGE_LOCK_FILE, PWRFORGE_PKG_PATH
from pwrforge.logger import get_logger

logger = get_logger()


def copy_file_if_not_exists(project_path: Path) -> None:
    """
    Copy files from pwrforge templates folder, preserving directory structure.

    For most files:
        - copy only if the file does not exist in the target project.

    For the .devcontainer wheel:
        - always remove old wheel(s) from the project
        - always copy the current wheel from templates
    """
    templates_root = Path(PWRFORGE_PKG_PATH, "templates")

    # 1) Remove all old wheel files from the project .devcontainer directory
    for old_wheel in project_path.glob(".devcontainer/pwrforge-*-py3-none-any.whl"):
        try:
            old_wheel.unlink()
            logger.info("Removed old wheel: %s", old_wheel)
        except OSError as exc:
            logger.warning("Could not remove old wheel %s: %s", old_wheel, exc)

    # 2) Define the current wheel file name (the one generated by build.py)
    current_wheel_rel = Path(".devcontainer") / f"pwrforge-{__version__}-py3-none-any.whl"

    # 3) Copy templates
    for src in templates_root.rglob("*"):
        if not src.is_file():
            continue

        rel_path = src.relative_to(templates_root)
        dst = project_path / rel_path

        # Always overwrite the wheel file â€“ we want the freshest version
        if rel_path == current_wheel_rel:
            dst.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(src, dst)
            logger.info("Copied current wheel %s -> %s", src, dst)
            continue

        # Default behavior for all other files: copy only if missing
        if not dst.exists():
            dst.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(src, dst)
            logger.info("Copied %s -> %s", src, dst)


def pwrforge_update(config_file_path: Path) -> None:
    """
    Update project

    :param config_file_path: path to .toml configuration file (e.g. pwrforge.toml)
    :return: None
    """
    project_path = config_file_path.parent
    docker_path = Path(project_path, ".devcontainer")
    vscode_path = Path(project_path, ".vscode")
    config = get_pwrforge_config_or_exit(config_file_path)

    # Copy templates project files to repo directory
    copy_file_if_not_exists(project_path)

    # Copy config file and create lock file.
    lock_path = project_path / PWRFORGE_LOCK_FILE
    shutil.copyfile(config_file_path, lock_path)
    ###########################################################################
    add_version_to_pwrforge_lock(lock_path)
    project_config = config.project

    # Copy docker env files to repo directory
    generate_docker_compose(docker_path, config)
    generate_env(docker_path, config)

    generate_vscode(vscode_path, config)

    generate_cmake(config)
    generate_conanfile(config)
    generate_conanprofile(config)

    if project_config.is_esp32():
        Path(config.source_dir_path, "fs").mkdir(parents=True, exist_ok=True)
        with open(Path(project_path, "version.txt"), "w", encoding="utf-8") as out:
            out.write(project_config.version)
        with open(Path(project_path, "partitions.csv"), "w", encoding="utf-8") as out:
            out.write("# ESP-IDF Partition Table\n# Name,   Type, SubType, Offset,  Size, Flags\n")
            partitions = config.get_esp32_config().partitions
            for line in partitions:
                out.write(line + "\n")
            out.write("\n")

    generate_cicd(config)
    generate_tests(config)
    generate_readme(config)

    # do not rebuild dockers in the docker
    if project_config.is_docker_buildenv():
        if not Path("/.dockerenv").exists():
            if not pull_docker_image(docker_path):
                pwrforge_docker_build([], config.project_root)
        else:
            logger.warning("Cannot run docker inside docker")

    build_dir = config.project_root / "build"
    if not build_dir.exists():
        return

    build_dir_empty = not any(build_dir.iterdir())
    if build_dir_empty:
        return

    logger.warning("Project build folder was not empty before the update.")
    logger.warning("Potential cache conflicts with the previous build - use 'clean' command in case of problems.")


def pull_docker_image(docker_path: Path) -> bool:
    logger.info("Pulling the image from docker registry...")
    try:
        cmd = get_docker_compose_command()
        cmd.extend(["pull"])
        result = subprocess.run(
            cmd,
            cwd=docker_path,
            stderr=subprocess.PIPE,
            check=True,
        )
    except subprocess.CalledProcessError:
        logger.info("No docker image does exist yet in the registry or you are not login")
    else:
        # happens for the default tag, like "myproject-dev:1.0"
        if "Some service image(s) must be built from source" not in result.stderr.decode():
            logger.info("Docker image pulled successfully")
            return True
    return False
